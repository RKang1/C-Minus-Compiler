COP4620 Construction of Language Translators
Student Name: Richard Kang
Instructor Name: Dr. Roger Eggen

To run this program:
javac *.java
java Part2 {file name}

*Note: {file name} can be named anything and must be in the same directory as the rest of the files.

This program accepts an input and runs a lexical analyzer on it to obtain a list of tokens.
Then it tests whether those tokens can be syntactically generated by the grammar defined in Compiler Construction: Principles and Practice by Kennet C. Louden on page 491.
While checking the syntax, this program also checks the semantics to see the input is accepted or rejected.

A key aspect of this program is a symbol table of ID objects that are hashed by their ID text.
These ID objects contain the ID text, ID type, parent function, parameter types, whether it is a function, and whether it is an array.
	Note that not all ID's require all of these fields.
The symbol table uses separate chaining for collision resolution and adds new items to the end of the linked list.
When searching for an ID, if multiple IDs have been hashed to the same location, the search starts at the end of the list of IDs at that location.
This allows the variables with the nearest scope to be found first since they would have been added the most recently.


Several specific semantic checks that are performed are as follows:
Functions declared as an int, or a float, must return the appropriate type.

Void functions may or may not have a return, but must not return a value.

Parameters and arguments agree in type and number.
	This is done by creating a string of the types of the parameters, and assigning it to the ID object of the function.
	Then, when there is a function call, a string of argument types is created and compared to the string of parameter types.
	If they are different, then either the number or the types are not the same.
	
No mixed mode arithmetic.

Arrays must have an int as the index.

All variables and functions must be declared before they are used.

All variables may only be declared once per scope.

Each function must have a different name.

When a variable is used, the ID object with that variable name in the closest scope is searched for and used.

There must be a main function and it must be declared last.

Variables are not allowed to be void.
